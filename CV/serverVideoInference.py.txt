import socket
import sys
import time
import threading
import cv2
import os
import torch
import glob
from datetime import datetime
from PIL import Image

mdp_dict = {11: 'Digit 1\nImage ID = 11', 
            12: 'Digit 2\nImage ID = 12', 
            13: 'Digit 3\nImage ID = 13', 
            14: 'Digit 4\nImage ID = 14', 
            15: 'Digit 5\nImage ID = 15', 
            16: 'Digit 6\nImage ID = 16', 
            17: 'Digit 7\nImage ID = 17', 
            18: 'Digit 8\nImage ID = 18', 
            19: 'Digit 9\nImage ID = 19', 
            20: 'Alphabet A\nImage ID = 20', 
            21: 'Alphabet B\nImage ID = 21', 
            22: 'Alphabet C\nImage ID = 22', 
            23: 'Alphabet D\nImage ID = 23', 
            24: 'Alphabet E\nImage ID = 24', 
            25: 'Alphabet F\nImage ID = 25', 
            26: 'Alphabet G\nImage ID = 26', 
            27: 'Alphabet H\nImage ID = 27', 
            28: 'Alphabet S\nImage ID = 28', 
            29: 'Alphabet T\nImage ID = 29', 
            30: 'Alphabet U\nImage ID = 30', 
            31: 'Alphabet V\nImage ID = 31', 
            32: 'Alphabet W\nImage ID = 32', 
            33: 'Alphabet X\nImage ID = 33', 
            34: 'Alphabet Y\nImage ID = 34',
            35: 'Alphabet Z\nImage ID = 35', 
            36: 'Up Arrow\nImage ID = 36', 
            37: 'Down Arrow\nImage ID = 37', 
            38: 'Right Arrow\nImage ID = 38', 
            39: 'Left Arrow\nImage ID = 39', 
            40: 'STOP\nImage ID = 40'} 
            # 41: 'BULLSEYE\nImage ID = 41'}

now = datetime.now()
current_time = now.strftime("%H:%M%S:%f")
model = torch.hub.load('ultralytics/yolov5', 'custom', path='itreallyisthebest.onnx', force_reload = True)
label_counts = {} 

def plot_boxes(image, labels, cord_thres):
    n = len(labels)
    x_shape, y_shape = image.shape[1], image.shape[0]

    for i in range(n):
        row = cord_thres[i]
        if (row[4] >= 0.5):
            x1, y1, x2, y2 = int(row[0] * x_shape), int(row[1] * y_shape), int(row[2] * x_shape), int(row[3] * y_shape)
            bgr = (0, 255, 0)
            cv2.rectangle(image, (x1, y1), (x2, y2), bgr, 2)
            label_id = int(labels[i]) + 37
            print(row[4])

            if label_id in mdp_dict:
                label_text = mdp_dict[label_id]
                lines = label_text.split('\n')  # Split the text into lines

                y_offset = y1
                for line in lines:
                    cv2.putText(image, line, (x1, y_offset), cv2.FONT_HERSHEY_SIMPLEX, 0.6, bgr, 2)
                    y_offset += 20  # Adjust the vertical spacing between lines

            if label_id in label_counts:
                label_counts[label_id] += 1
            else:
                label_counts[label_id] = 1

    return image

def load_video_from_file(video_path, output_directory):
    label_counts = {}
    max_bbox_area = 0
    nearest_label = None
    consecutive_label_count = {}  # Track consecutive occurrences of labels
    consecutive_frames = 2  # Number of consecutive frames to trigger saving the 5th frame
    frame_number = 0  # Track the frame number
    cap = cv2.VideoCapture(video_path)
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        resized = cv2.resize(frame, (640, 640), interpolation=cv2.INTER_CUBIC)
        resized_coloured = cv2.cvtColor(resized, cv2.COLOR_BGR2RGB)
        results = model(resized_coloured)

        # Move tensors from GPU to CPU [IMPORTANT]
        labels = results.xyxyn[0][:, -1].cpu().numpy()
        cord_thres = results.xyxyn[0][:, :-1].cpu().numpy()

        image_with_bounding_box = plot_boxes(resized, labels, cord_thres)

        cv2.imshow('Predicted Output', image_with_bounding_box)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
        
        if len(labels) == 0:
            frame_number = int(cap.get(cv2.CAP_PROP_POS_FRAMES))
            print("Frame Number =", frame_number, "Image ID: <<NO OBJECT DETECTED>>")
        else:
            for label in labels:
                label = int(label) + 37
                frame_number = int(cap.get(cv2.CAP_PROP_POS_FRAMES))
                inference_result = mdp_dict.get(label, 'Unknown Label')
                print("Frame Number =", frame_number, "Image ID:", inference_result)
                
                if label in label_counts:
                    label_counts[label] += 1
                else:
                    label_counts[label] = 1

        # Check labels and find the nearest object based on the largest bounding box area
        detected_labels = []
        for label, (x1, y1, x2, y2, conf) in zip(labels, cord_thres):
            label = int(label) + 37
            bbox_area = (x2 - x1) * (y2 - y1)
            if bbox_area > max_bbox_area and conf >= 0.75:
                max_bbox_area = bbox_area
                nearest_label = label

            if label in label_counts:
                label_counts[label] += 1
                if label in consecutive_label_count and consecutive_label_count[label] >= consecutive_frames:
                    # Save the 5th frame only once in consecutive occurrences
                    if label_counts[label] == 4:
                        frame_filename = f'frame_{label}.png'  # Save the frame with label as filename
                        received_file_path = os.path.join(output_directory, frame_filename)
                        # Rename the file if it already exists
                        file_number = 1
                        while os.path.exists(received_file_path):
                            new_file_name = f'frame_{label}_{file_number}.png'
                            received_file_path = os.path.join(output_directory, new_file_name)
                            file_number += 1
                        cv2.imwrite(received_file_path, resized)
                        print(f'Saved frame {frame_number} with label {label} as {frame_filename}')
                        break  # Exit the loop after saving the frame
            else:
                label_counts[label] = 1
                
            consecutive_label_count[label] = label_counts[label]

        frame_number += 1

    cap.release()
    cv2.destroyAllWindows()

    # If multiple objects are found, return the label that is not 41 (BULLSEYE)
    if nearest_label is not None:
        nearest_inference_result = mdp_dict.get(nearest_label, 'Unknown Label')
        print("Nearest Inference for current run:", nearest_inference_result)
        return nearest_label
    else:
        print("No objects found.")
        return 60 # 60 is the label for no object detected

def handle_mdp(conn, addr):
    try:
        while True:
            print("Waiting for data")

            file_size = int(conn.recv(1024).decode())
            print(file_size)
            total_bytes_received = 0

            base_path = 'videos'
            file_name = 'received_video.h264'
            received_file_path = os.path.join(base_path, file_name)

            # Rename the file if it already exists
            file_number = 1
            while os.path.exists(received_file_path):
                new_file_name = f'received_video_{file_number}.h264'
                received_file_path = os.path.join(base_path, new_file_name)
                file_number += 1

            with open(received_file_path, 'wb') as file:
                while total_bytes_received < file_size:
                    data = conn.recv(1024)
                    if not data:
                        break
                    file.write(data)
                    total_bytes_received += len(data)

            file.close()
            print(f"Received {total_bytes_received} bytes, File transfer completed. Saved as: {received_file_path}")

            # Video Inference
            output_directory = 'runsVideoOutput'
            results = load_video_from_file(received_file_path, output_directory)
            
            results_str = str(results)
            print(results_str)

            # Send the result to RPI
            conn.sendall(results_str.encode())
            print("Msg sent to RPI: " + results_str)
                
            # Continuously check for new PNG files 
            while True:
                png_files_before = count_png_files_in_directory(output_directory)
                time.sleep(5)  # Wait for 10 seconds
                png_files_after = count_png_files_in_directory(output_directory)
                
                # If new PNG files have been added, reset the countdown
                if png_files_after > png_files_before:
                    print(png_files_before, png_files_after)
                    continue
                
                elif png_files_after == png_files_before or png_files_after == 2:
                    collage_output_path = 'collage.png'
                    create_collage(output_directory, collage_output_path)
                    break

            conn.shutdown(socket.SHUT_WR)

    except Exception as ex:
        print(ex)
        
def create_collage(input_folder, output_path):
    images = []
    max_width, max_height = 0, 0

    for filename in os.listdir(input_folder):
        if filename.endswith('.jpg') or filename.endswith('.png'):
            img_path = os.path.join(input_folder, filename)
            img = Image.open(img_path)
            images.append(img)
            max_width = max(max_width, img.width)
            max_height = max(max_height, img.height)

    num_cols = 2
    num_rows = 1
    collage_width = max_width * num_cols
    collage_height = max_height * num_rows
    collage = Image.new('RGB', (collage_width, collage_height))
    x_offset, y_offset = 0, 0

    for img in images:
        collage.paste(img, (x_offset, y_offset))
        x_offset += max_width
        if x_offset >= collage_width:
            x_offset = 0
            y_offset += max_height
    
    collage.save(output_path)
    collage.show()  # Show the collage
    print(f"Collage created and saved at: {output_path}")
    
def count_png_files_in_directory(directory):
    # Initialize a counter for the number of .png files
    png_file_count = 0

    # Iterate through the files in the directory
    for filename in os.listdir(directory):
        if filename.endswith('.png'):
            png_file_count += 1

    return png_file_count

try:
    print("Starting server")

    s = socket.socket()
    s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

    s.bind(('192.168.36.28',12345)) #this is the main one
    # s.bind(('10.91.104.0', 12345))
    #s.bind(('192.168.36.19',12345))
    # s.bind(('10.91.212.184', 12345))
    s.listen(1)

    print("Connected to RPi...")

    while True:
        conn,addr = s.accept()
        print("Connected by:",addr)

        t = threading.Thread(target = handle_mdp,args = (conn,addr))
        t.start()
        
except Exception as ex:
    print(ex)

