from multiprocessing import Process, Value, Queue, Manager, Lock
import string
import time
from datetime import datetime

# from RPI_PC import PcComm
from RPI_Android import AndroidComm
from RPI_STM import STMComm
from RPI_PC import PcComm
# from IP import ImageProcessor
from config import MESSAGE_SEPARATOR, LOCALE
from colorama import *
from img_recv2 import *
import json

from picamera import PiCamera

import time

init(autoreset=True)
label = ''

class MultiProcessCommunication:

    def __init__(self):

        self.stm = STMComm()
        self.android = AndroidComm()

        self.manager = Manager()

        self.message_queue = self.manager.Queue()
        self.to_android_message_queue = self.manager.Queue()


        self.lock = self.manager.Lock()
        self.ack = Value('i', 1) # for STM to tell RPI it is ready for next command.
        self.loopNext = Value('i', 0) # for internal command like R,T,G,F for STM to tell RPI it is ready for next command.

        #Read STM theard with lock and race condition value moveNext and loopNext
        self.read_stm_process = Process(target=self._read_stm, args=(self.ack,self.loopNext,self.lock))
        #Read                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           AND thread
        self.read_android_process = Process(target=self._read_android)

        #Write theard with lock and race condition value moveNext and loopNext
        self.write_process = Process(target=self._write_target, args=(self.ack,self.loopNext,self.lock))
        #Write AND thread
        print(Fore.LIGHTGREEN_EX + '[MultiProcess] MultiProcessing initialized')

        self.dropped_connection = Value('i', 0)

        self.sender = None
        self.img1 = None
        self.img2 = None

    def start(self):
        try:
            # Connect to STM, Algorithm (PC) and Android
            self.stm.connect_stm()
            self.android.connect_android()

            # Start the process to read and write to various modules (STM, Algorithm [PC] and Android)
            self.read_stm_process.start()
            self.read_android_process.start()

            self.write_process.start()
            startComms_dt = datetime.now().strftime('%d-%b-%Y %H:%M%S')
            print(Fore.LIGHTGREEN_EX + str(startComms_dt) + '| [MultiProcess] Communications started. Reading from STM, Algorithm & Android')


        except Exception as e:
            print(Fore.RED + '[MultiProcess-START ERROR] %s' % str(e))
            raise e

        self._allow_reconnection()

    #Reconnect algo if any connection is not alive start reconnect
    def _allow_reconnection(self):
        while True:
            try:
                #check if the process is not executing and reconnect

                if not self.read_android_process.is_alive():
                    self._reconnect_android()

                if not self.write_process.is_alive():
                    self.write_process.terminate()
                    self.write_process = Process(target=self._write_target , args=(self.ack,self.loopNext,self.lock))
                    self.write_process.start()




            except Exception as e:
                print(Fore.RED + '[MultiProcess-RECONN ERROR] %s' % str(e))
                raise e

    #Disconnect STM connection kill all read/write STM thread then reconnect and reinitlize all read/write thread
    def _reconnect_stm(self):
        self.stm.disconnect_stm()

        self.read_stm_process.terminate()


        self.stm.connect_stm()

        self.read_stm_process = Process(target=self._read_stm)
        self.read_stm_process.start()



        print(Fore.LIGHTGREEN_EX + '[MultiProcess-RECONN] Reconnected to STM')


    #Disconnect AND connection kill all read/write STM thread then reconnect and reinitlize all read/write thread
    def _reconnect_android(self):
        self.android.disconnect_android()

        self.read_android_process.terminate()


        self.android.connect_android()

        self.read_android_process = Process(target=self._read_android)
        self.read_android_process.start()



        print(Fore.LIGHTGREEN_EX + '[MultiProcess-RECONN] Reconnected to Android')

    #Function to format message into dic[key:target] value:payload
    def _format_for(self, target, message):
        return {
            'target': target,
            'payload': message,
        }

    #Read AND loop
    def _read_android(self):
        while True:
            try:
                raw_message = self.android.read_from_android()

                if raw_message is None:
                    continue


                raw_message_list = raw_message.decode()

                #For start button
                if len(raw_message_list) != 0:
                    self.message_queue.put_nowait(self._format_for('STM', raw_message_list.encode(LOCALE)))
                    print(Fore.LIGHTCYAN_EX + 'Command to start robot send')
                    print(raw_message_list)




            except Exception as e:
                print(Fore.RED + '[MultiProcess-READ-AND ERROR] %s' % str(e))
                break

        #Read STM loop
    def _read_stm(self, ack, loopNext , lock):
        while True:
            try:
                raw_message = self.stm.read_from_stm()

                #check if raw_message is None or an empty bytes object
                if raw_message is None or raw_message == b'':
                    print(Fore.LIGHTBLUE_EX + 'No Message from STM')
                    continue

                raw_message_list = raw_message.decode().strip()
                #print(raw_message.decode())

                if(len(raw_message_list)!= 0):
                    print("start",raw_message_list)

                    if raw_message_list.startswith("ACK"):
                        lock.release()
                        self.ack.value += 1
                        print(self.ack.value)
                    if raw_message_list.isdigit():
                        self.ack.value += 1
                        print(self.ack.value)

                        #If STM send RPI:SCAN\n means take pic and tell STM all the next command
                        if(self.img1 is None):
                            print('scanning 1st image...')

                            #img rec func
                            #label = imgRec()


                            #If label is no null
                            label = '39'
                            if label!='':
                                #RIGHT
                                if(str(label) == "38"):
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FR045".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FC013".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|BL045".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|XX025".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|BC010".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                #LEFT
                                elif(str(label) == "39"):
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FL045".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|FC015".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|BR045".encode(LOCALE)))
                                    self.message_queue.put_nowait(self._format_for("STM", "STM|XX025".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|BC010".encode(LOCALE)))
                                    # self.message_queue.put_nowait(self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                #Set img1
                                self.img1 = str(label)
                                print(Fore.BLUE + 'Obstacle 1 done')

                            else:
                                print(Fore.RED + 'No image detected!')

                        #when 1st image is recieved
                        elif(self.img2 is None):
                            print('scanning 2nd image...')

                            #label = imgRec()
                            self.img2 = str(label)
                            label = '38'

                            if str(label) == "38":
                                print(Fore.BLUE + 'Obstacle 2 detected')
                                print(Fore.RED + "RIGHT")
                                # Right
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FL090".encode(LOCALE)))

                                self.message_queue.put_nowait(self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                #round the second obstacle
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FC019".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                #get back to parking place
                                self.message_queue.put_nowait(self._format_for("STM", "STM|XX040".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FL045".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FR045".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|XX015".encode(LOCALE)))
                                #self.img1 = None
                                break



                            elif str(label) == "39":
                                # Left
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FL090".encode(LOCALE)))
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                self.message_queue.put_nowait(
                                    self._format_for("STM", "STM|FR090".encode(LOCALE)))

                                self.message_queue.put_nowait(self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                #round the second obstacle
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FC019".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FR090".encode(LOCALE)))
                                #get back to parking place
                                self.message_queue.put_nowait(self._format_for("STM", "STM|XX040".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FR045".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FC005".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|FL045".encode(LOCALE)))
                                self.message_queue.put_nowait(self._format_for("STM", "STM|XX015".encode(LOCALE)))
                                #self.img1 = None
                                break








            except Exception as e:
                print(Fore.RED + '[MultiProcess-READ-STM ERROR] %s' % str(e))
                break

    def _write_target(self , ack, loopNext, lock):
        while True:
            target = None
            try:
                if not self.message_queue.empty():
                    message = self.message_queue.get_nowait()
                    target, payload = message['target'], message['payload']
                    if target == 'STM':
                        lock.acquire()
                        #with lock:
                            # Wait for the ACK flag to be set
                            #while self.ack.value == 0:
                                    #print("waiting for ACK")
                                    #pass

                            # Reset the ACK flag after processing the ACK
                        self.ack.value = 0
                        print("ACK recieved")

                        #Check if command is STM|START
                        if(payload.decode() == 'STM|START'):
                            time.sleep(0.5)
                            #self.stm.write_to_stm('STM|FC000'.encode())
                            data = "STM|XX030"    #if STM can interrupt we change
                            self.stm.write_to_stm(data.encode())


                        else:
                            time.sleep(0.5)
                            self.stm.write_to_stm(payload)


            except Exception as e:
                print(Fore.RED + '[MultiProcess-WRITE-%s ERROR] %s' % (str(target), str(e)))

                if target == 'STM':
                    self.dropped_connection.value = 0

                elif target == 'ALG':
                    self.dropped_connection.value = 1

                break


def init():
    try:
        multi = MultiProcessCommunication()
        multi.start()
    except Exception as err:
        print(Fore.RED + '[Main.py ERROR] {}'.format(str(err)))

if __name__ == '__main__':
    init()

#for second obs
#first block of code navigate the front face of obstacle

#for opposite face of second obstacle
# assuming we start at the edge of obj
    #set timer start
    #run fc (stm stops when reach end of obj)
    #end timer
    #calculate distance using robot speed x time
    #distance/2
    #navigate back to distance/2
